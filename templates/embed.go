package templates

// FSGo holds stored (embedded) files template
const FSGo = `package embed

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"io/ioutil"
	"sync"
)

// storage holds a map (key/value) which corresponds
// to filepath (string) "./embed/filename" and file data (string)
// when app inits all embedded audio files are loaded here
var storage = make(map[string]string)
var mutex = &sync.Mutex{}

// List returns all audio files (wav/aiff)
// stored in binary via 'gocomu embed'
// for example you can use embed.List() to range over available
// stored files and subsequently use embed.Open to open them
func List() []string {
	var list []string
	for v := range storage {
		list = append(list, v)
	}
	return list
}

// Open a file (*bytes.Reader) stored in binary.
// It is safe to be used with goroutines.
// Conveniently is can be used along os.Open("path/to/file")
// and when you are ready to build a standalone app
// replace os.Open with embed.Open
func Open(filepath string) (*bytes.Reader, error) {
	var val string
	var ok bool

	mutex.Lock()
	// check if filepath exists in storage
	if val, ok = storage[filepath]; !ok {
		// if not a gracefull error returns
		return nil, fmt.Errorf("File '%s' doesn't exist/wrong filepath", filepath)
	}
	mutex.Unlock()

	// decode from base64 to []byte
	data, err := base64.StdEncoding.DecodeString(val)
	if err != nil {
		return nil, err
	}

	// create a new reader and load the data ([]byte)
	datareader := bytes.NewReader(data)

	// ungzip the data ([]byte)
	gzipReader, err := gzip.NewReader(datareader)
	if err != nil {
		return nil, err
	}
	defer gzipReader.Close()

	// load the reader to a new []byte
	bt, _ := ioutil.ReadAll(gzipReader)

	// re-assign a new reader to the decoded & unzgziped data ([]byte)
	datareader = bytes.NewReader(bt)
	return datareader, nil
}

// add is the function embedded audio files call when app is init'ing
func add(filepath string, data string) {
	mutex.Lock()
	storage[filepath] = data
	mutex.Unlock()
}
`

const EmbedGo = `//+build embed

package main

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
	"regexp"
	"strings"

	"github.com/gocomu/cli"
	gonanoid "github.com/matoous/go-nanoid"
)

func main() {
	// check if dir is project top dir
	_, err := cli.Yaml()
	if err != nil {
		fmt.Println(err)
		fmt.Println("You should only run \"gocomu embed\" when inside top project dir")
		return
	}

	dir, _ := os.Getwd()

	// walk through /embed
	filepath.Walk(dir+"/embed", func(path string, info os.FileInfo, err error) error {
		if err != nil {
			fmt.Printf("%q: %v\n", path, err)
			return err
		}

		if info.IsDir() {
		} else {
			if strings.HasPrefix(info.Name(), "gocomu-") {
				// delete previously generated gocomu files
				os.Remove(path)
			}

			if strings.HasSuffix(info.Name(), ".wav") || strings.HasSuffix(info.Name(), ".aiff") {
				filePath := strings.TrimPrefix(path, dir+"/")

				fileName := strings.TrimSuffix(info.Name(), filepath.Ext(path))
				fileName = strings.TrimSpace(fileName)
				fileName = strings.Replace(fileName, " ", "", -1)
				reg, err := regexp.Compile("[^a-zA-Z0-9]+")
				if err != nil {
					return err
				}
				fileName = reg.ReplaceAllString(fileName, "")
				embed(dir, filePath, fileName, path)
				userNotice(filePath)
			}

		}

		return nil
	})
}

func embed(dir, filePath, fileName, path string) {
	ff, err := ioutil.ReadFile(path)
	if err != nil {
		fmt.Println("ioutil error : ", err)
	}

	var buf bytes.Buffer
	gzza, _ := gzip.NewWriterLevel(&buf, gzip.BestCompression)
	if _, err := gzza.Write(ff); err != nil {
		panic(err)
	}
	if err := gzza.Close(); err != nil {
		panic(err)
	}
	
	str := base64.StdEncoding.EncodeToString(buf.Bytes())

	tpl := fmt.Sprintf("package embed \n\n// Autogenerated by GOCOMU - Do not alter\n\nfunc init() {\n	const data = \"%s\"\n	go add(\"%s\", data)\n}", str, filePath)

	nanouid, _ := gonanoid.Generate("gocomu", 6)

	ioutil.WriteFile(dir+"/embed/"+"gocomu-"+fileName+"-"+nanouid+".go", []byte(tpl), 0644)
}

func userNotice(filePath string) {
	fmt.Printf("Embedded \"%s\" successfully! \n", filePath)
}
`
