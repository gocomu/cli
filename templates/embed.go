package templates

// FSGo holds stored (embedded) files template
const FSGo = `package embed

import (
	"bytes"
	"compress/gzip"
	"encoding/hex"
	"fmt"
	"io/ioutil"
	"sync"
)

// storage holds a map (key/value) which corresponds
// to filepath (string) "./embed/filename" and file data (string)
// when app inits all embedded audio files are loaded here
var storage = make(map[string]string)
var mutex = &sync.Mutex{}

// Open a file (*bytes.Reader) stored in binary.
// It is safe to be used with goroutines.
// Conveniently is can be used along os.Open("path/to/file")
// and when you are ready to build a standalone app
// replace os.Open with embed.Open
func Open(filepath string) (*bytes.Reader, error) {
	// done and errRet channels are used
	// to either return the file or an error
	reader := make(chan *bytes.Reader)
	errRet := make(chan error)

	go func() {
		var strng string
		mutex.Lock()
		// check if filepath exists in storage
		if val, ok := storage[filepath]; !ok {
			// if not a gracefull error returns
			errRet <- fmt.Errorf("File '%s' doesn't exist/wrong filepath", filepath)
		} else {
			// get the file data from storage
			strng = val
		}
		mutex.Unlock()

		// decode from hex to []byte
		data, err := hex.DecodeString(strng)
		if err != nil {
			errRet <- err
		}

		// create a new reader and load the data ([]byte)
		datareader := bytes.NewReader(data)

		// ungzip the data []byte
		gzipReader, err := gzip.NewReader(datareader)
		if err != nil {
			errRet <- err
		}
		defer gzipReader.Close()

		// load the reader to a new []byte
		bt, _ := ioutil.ReadAll(gzipReader)

		// re-assign the reader to the decoded & unzgziped data ([]byte)
		datareader = bytes.NewReader(bt)
		reader <- datareader
	}()

	// block the function here and wait for either
	// done or errRet channel to send a message
	select {
	case data := <-reader:
		return data, nil
	case err := <-errRet:
		return nil, err
	}
}

// add is the function embedded audio files call when app is init'ing
func add(filepath string, data string) {
	mutex.Lock()
	storage[filepath] = data
	mutex.Unlock()
}
`

const EmbedGo = `//+build embed

package main

import (
	"bytes"
	"compress/gzip"
	"encoding/hex"
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
	"regexp"
	"strings"

	"github.com/gocomu/cli"
	gonanoid "github.com/matoous/go-nanoid"
)

func main() {
	// check if dir is project top dir
	_, err := cli.Yaml()
	if err != nil {
		fmt.Println(err)
		fmt.Println("You should only run \"gocomu embed\" when inside top project dir")
		return
	}

	dir, _ := os.Getwd()

	// walk through /embed
	filepath.Walk(dir+"/embed", func(path string, info os.FileInfo, err error) error {
		if err != nil {
			fmt.Printf("%q: %v\n", path, err)
			return err
		}

		if info.IsDir() {
		} else {
			if strings.HasPrefix(info.Name(), "gocomu-") {
				// delete previously generated gocomu files
				os.Remove(path)
			}

			if strings.HasSuffix(info.Name(), ".wav") || strings.HasSuffix(info.Name(), ".aiff") {
				filePath := strings.TrimPrefix(path, dir+"/")

				fileName := strings.TrimSuffix(info.Name(), filepath.Ext(path))
				fileName = strings.TrimSpace(fileName)
				fileName = strings.Replace(fileName, " ", "", -1)
				reg, err := regexp.Compile("[^a-zA-Z0-9]+")
				if err != nil {
					return err
				}
				fileName = reg.ReplaceAllString(fileName, "")
				embed(dir, filePath, fileName, path)
				userNotice(filePath)
			}

		}

		return nil
	})
}

func embed(dir, filePath, fileName, path string) {
	ff, err := ioutil.ReadFile(path)
	if err != nil {
		fmt.Println("ioutil error : ", err)
	}

	var buf bytes.Buffer
	gzza := gzip.NewWriter(&buf)
	if _, err := gzza.Write(ff); err != nil {
		panic(err)
	}
	if err := gzza.Close(); err != nil {
		panic(err)
	}
	str := hex.EncodeToString(buf.Bytes())

	tpl := fmt.Sprintf("package embed \n\n// Autogenerated by GOCOMU - Do not alter\n\nfunc init() {\n	const data = \"%s\"\n	go add(\"%s\", data)\n}", str, filePath)

	nanouid, _ := gonanoid.Generate("gocomu", 6)

	ioutil.WriteFile(dir+"/embed/"+"gocomu-"+fileName+"-"+nanouid+".go", []byte(tpl), 0644)
}

func userNotice(filePath string) {
	fmt.Printf("Embedded \"%s\" successfully! \n", filePath)
}
`
